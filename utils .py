# -*- coding: utf-8 -*-
"""utils.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/13aQfcMaf1Phu59wbw2MamgLNjS9kUJhf
"""
import numpy as np
import random 
from math import sqrt

class Dataset:
  def __init__(self,num_dataPoints):
    self.num_dataPoints = num_dataPoints

  def get(self,add_noise = False):
    num_points = self.num_dataPoints

    dataset = []
    labels = []
    for i in range(num_points):
      x = random.uniform(-1,1)
      choice1 = random.randrange(-100,100)
      choice2 = random.randrange(-100,100)

      if choice1>=0 and choice2>=0:
        y = sqrt(1-(x**2))
        labels.append(0)
      elif choice1>=0 and choice2<0:
        y = -1*sqrt(1-(x**2))
        labels.append(0)
      elif choice1<0 and choice2>=0:
        y = sqrt(1-(x**2))+3
        labels.append(1)
      else:
        y = (-1*sqrt(1-(x**2)))+3
        labels.append(1)

      if add_noise:
        noise = np.random.normal(0,0.1,len([x,y]))
        dataset.append(noise+[x,y])
      else:
        dataset.append([x,y])
    dataset = np.array(dataset)
    labels = np.array(labels)
    return dataset,labels

class Perceptron:

  def __init__(self,num_features,fixed_bias = False):
    self.weights = np.zeros(num_features)
    self.bias = 0
    self.fixed_bias = fixed_bias

  def activation_func(self,x):
    if x>0:
      return 1
    else:
      return 0

  def check_convergence(self,flag):
    if flag==0:
      return True
    else:
      return False

  def fit(self,train_X,train_Y):
    t=1000
    while t:
      print(t)
      t-=1
      flag = 0
      for i in range(len(train_X)):
        err = train_Y[i] - self.activation_func(np.dot(train_X[i],self.weights)+self.bias)

        if(err!=0):
          flag = 1
          for j in range(len(train_X[i])):
            self.weights[j] = self.weights[j] + (err*train_X[i][j])
          if self.fixed_bias == False:
            self.bias = self.bias + err

      if(self.check_convergence(flag)):
        break
          
  def predict(self,test_X):
    return self.activation_func(np.dot(test_X,self.weights)+self.bias)
  def get_weights(self):
    return [self.weights,self.bias]
